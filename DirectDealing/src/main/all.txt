Le dossier ./java/eu/telecomnancy/labfx/ contient les fichiers suivants:

CombinedOffer.java
ConsultEquipmentController.java
ConsultServiceController.java
CreateEquipmentController.java
CreateServiceController.java
DataBase.java
EquipmentController.java
EquipmentOffer.java
EquipmentOfferController.java
HomeController.java
InscriptionController.java
Main.java
MainController.java
MapController.java
MenuController.java
MessagerieController.java
Planning.java
PlanningController.java
PrivateProfileController.java
ProfileController.java
PublicProfileController.java
ServiceController.java
ServiceOffer.java
ServiceOfferController.java
SkeletonController.java
User.java
messagerie


Le contenu des fichiers est le suivant:

package eu.telecomnancy.labfx;

import java.time.LocalDate;
import java.time.LocalTime;

public class CombinedOffer {
    // Champs communs
    private int id;
    private User owner;
    private String title;
    private String description;
    private int price;
    private String estPris;
    private String date_publication;
    private LocalDate start;
    private LocalDate end;
    private double distanceToCurrentUser;

    // Champs spécifiques à EquipmentOffer
    private int quantity;

    // Champs spécifiques à ServiceOffer
    private LocalTime time;
    private boolean isRecurrent;
    private String daysOfService;
    private int nbRecurrencingWeeks;

    // Type de l'offre pour différencier EquipmentOffer de ServiceOffer
    private OfferType type;

    public enum OfferType {
        EQUIPMENT_OFFER, SERVICE_OFFER
    }

    // Constructeur pour EquipmentOffer
    public CombinedOffer(EquipmentOffer equipmentOffer) {
        this.id = equipmentOffer.getId();
        this.owner = equipmentOffer.getOwner();
        this.title = equipmentOffer.getName();
        this.description = equipmentOffer.getDescription();
        this.price = equipmentOffer.getPrice();
        this.estPris = equipmentOffer.getEstPris();
        this.quantity = equipmentOffer.getQuantity();
        this.start = equipmentOffer.getStartAvailability();
        this.end = equipmentOffer.getEndAvaibility();
        this.type = OfferType.EQUIPMENT_OFFER;
        this.date_publication = equipmentOffer.getDate_publication();
    }

    // Constructeur pour ServiceOffer
    public CombinedOffer(ServiceOffer serviceOffer) {
        this.id = serviceOffer.getId();
        this.owner = serviceOffer.getSupplier();
        this.title = serviceOffer.getTitle();
        this.description = serviceOffer.getDescription();
        this.price = serviceOffer.getPrice();
        this.estPris = serviceOffer.getEstPris();
        this.start = serviceOffer.getStart();
        this.end = serviceOffer.getEnd();
        this.time = serviceOffer.getTime();
        this.isRecurrent = serviceOffer.getIsRecurrent();
        this.daysOfService = serviceOffer.getDaysOfService();
        this.nbRecurrencingWeeks = serviceOffer.getRecurrency();
        this.type = OfferType.SERVICE_OFFER;
        this.date_publication = serviceOffer.getDate_publication();
    }


    // Getters et setters pour les champs communs et spécifiques

    public OfferType getType() {
        return type;
    }

    public String getTypeString() {
        if (this.type == OfferType.EQUIPMENT_OFFER) {
            return "Equipment";
        } else {
            return "Service";
        }
    }

    // Autres getters et setters...
    public int getId() {
        return id;
    }

    public User getOwner() {
        return owner;
    }

    public String getOwnerName() {
        return owner.getNom();
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public int getPrice() {
        return price;
    }

    public String getEstPris() {
        return estPris;
    }

    public int getQuantity() {
        if (this.type == OfferType.EQUIPMENT_OFFER) {
            return quantity;
        } else {
            throw new UnsupportedOperationException("getQuantity is not supported for ServiceOffer");
        }
    }

    public LocalDate getStart() {
        return start;
    }

    public String getStartString() {
        return start.toString();
    }

    public LocalDate getEnd() {
        return end;
    }

    public String getEndString() {
        return end.toString();
    }

    public LocalTime getTime() {
        if (this.type == OfferType.SERVICE_OFFER) {
            return time;
        } else {
            throw new UnsupportedOperationException("getTime is not supported for EquipmentOffer");
        }
    }

    public boolean getIsRecurrent() {
        if (this.type == OfferType.SERVICE_OFFER) {
            return isRecurrent;
        } else {
            throw new UnsupportedOperationException("getIsRecurrent is not supported for EquipmentOffer");
        }
    }

    public String getDaysOfService() {
        if (this.type == OfferType.SERVICE_OFFER) {
            return daysOfService;
        } else {
            throw new UnsupportedOperationException("getDaysOfService is not supported for EquipmentOffer");
        }
    }

    public int getNbRecurrencingWeeks() {
        if (this.type == OfferType.SERVICE_OFFER) {
            return nbRecurrencingWeeks;
        } else {
            throw new UnsupportedOperationException("getNbRecurrencingWeeks is not supported for EquipmentOffer");
        }
    }

    public String getDate_publication() {
        return date_publication;
    }
}
package eu.telecomnancy.labfx;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.time.LocalDate;

public class DataBase {

    private static final String DB_FOLDER = "BD";
    private static final String DB_NAME = "DirectDealing.db";
    private static final String DB_URL = "jdbc:sqlite:" + DB_FOLDER + File.separator + DB_NAME;

    // Méthode pour obtenir une connexion à la base de données
    public static Connection getConnection() throws SQLException {
        File dbFolder = new File(DB_FOLDER);
        if (!dbFolder.exists()) {
            dbFolder.mkdir();
        }
        return DriverManager.getConnection(DB_URL);
    }

    // Méthode pour initialiser la base de données
    public static void initializeDatabase() {
        try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) {
            // Création de la table "profil" si elle n'existe pas
            String sqlProfil = "CREATE TABLE IF NOT EXISTS profil (" +
                             "id INTEGER PRIMARY KEY, " +
                             "prenom TEXT NOT NULL, " +
                             "nom TEXT NOT NULL, " +
                             "pseudo TEXT UNIQUE NOT NULL, " +
                             "mail TEXT UNIQUE NOT NULL, " +
                             "phone TEXT, " +
                             "password TEXT NOT NULL, " +
                             "photo_profil TEXT, " +
                             "localisation TEXT NOT NULL, " +
                             "date_inscription TEXT, " +
                             "status_compte TEXT CHECK(status_compte IN ('particulier', 'professionnel')), " +
                             "etat_compte TEXT CHECK(etat_compte IN ('sommeil', 'actif')), " +
                             "nb_florain INTEGER, " +
                             "historique_florain TEXT, " +
                             "note REAL)";
            stmt.execute(sqlProfil);

            // Ajout de admin dans la table "profil" si elle n'existe pas
            String emailToCheck = "admin"; // L'e-mail que tu veux vérifier
            // Préparer une requête SQL pour vérifier si l'e-mail existe déjà
            String sqlCheck = "SELECT COUNT(*) FROM profil WHERE mail = ?";
            try (PreparedStatement checkStmt = conn.prepareStatement(sqlCheck)) {
                checkStmt.setString(1, emailToCheck);

                // Exécuter la requête et obtenir le résultat
                ResultSet resultSet = checkStmt.executeQuery();
                if (resultSet.next()) {
                    int count = resultSet.getInt(1);

                    // Vérifier si l'e-mail existe déjà
                    if (count == 0) {
                        // L'e-mail n'existe pas, exécuter la requête d'insertion
                        String sqlAdmin = "INSERT INTO profil (prenom, nom, pseudo, mail, phone, password, localisation, date_inscription, status_compte, etat_compte, nb_florain, historique_florain, note) " +
                                        "VALUES ('admin', 'admin', 'admin', 'admin', '0000000000', 'admin', 'Paris', ?, NULL, 'actif', 10000, NULL, 5)";
                        try (PreparedStatement insertStmt = conn.prepareStatement(sqlAdmin)) {
                            insertStmt.setString(1, LocalDate.now().toString()); // Remplacer par la date actuelle
                            insertStmt.execute();
                        }
                    }
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }

            // Création de la table "equipement" si elle n'existe pas
            String sqlEquipement = "CREATE TABLE IF NOT EXISTS equipement (" +
                            "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                            "owner_mail TEXT NOT NULL, " +
                            "name TEXT NOT NULL, " +
                            "description TEXT, " +
                            "quantity INTEGER NOT NULL, " +
                            "start_availability TEXT, " +
                            "end_availability TEXT, " +
                            "price INTEGER NOT NULL, " +
                            "estPris TEXT, " +
                            "book_begin TEXT, " +
                            "book_end TEXT, " +
                            "date_publication TEXT, " +
                            "FOREIGN KEY (owner_mail) REFERENCES profil (mail), " +
                            "FOREIGN KEY (estPris) REFERENCES profil (mail))";
            stmt.execute(sqlEquipement);


            // Création de la table "service_offers" si elle n'existe pas
            String sqlServiceOffers = "CREATE TABLE IF NOT EXISTS service_offers (" +
                            "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                            "supplier_mail TEXT NOT NULL, " +
                            "title TEXT NOT NULL, " +
                            "description TEXT, " +
                            "start TEXT, " +
                            "end TEXT, " +
                            "time TEXT, " +
                            "is_recurrent BOOLEAN, " +
                            "days_of_service TEXT, " +
                            "price INTEGER, " +
                            "estPris TEXT, " +
                            "book_begin TEXT, " +
                            "book_end TEXT, " +
                            "date_publication TEXT, " +
                            "FOREIGN KEY (supplier_mail) REFERENCES profil (mail), " +
                            "FOREIGN KEY (estPris) REFERENCES profil (mail))";
            stmt.execute(sqlServiceOffers);
            
            

            // Création de la table "Conversations" si elle n'existe pas
            String sqlConversations = "CREATE TABLE IF NOT EXISTS conversations (" +
                                      "conversation_id INTEGER PRIMARY KEY," +
                                      "participant1_id INTEGER NOT NULL," +
                                      "participant2_id INTEGER NOT NULL);";
            stmt.execute(sqlConversations);

            // Création de la table "Messages" si elle n'existe pas
            String sqlMessages = "CREATE TABLE IF NOT EXISTS messages (" +
                                 "message_id INTEGER PRIMARY KEY," +
                                 "conversation_id INTEGER NOT NULL," +
                                 "sender_id INTEGER NOT NULL," +
                                 "receiver_id INTEGER NOT NULL," +
                                 "message_text TEXT NOT NULL," +
                                 "timestamp DATETIME DEFAULT CURRENT_TIMESTAMP," +
                                 "is_read BOOLEAN DEFAULT FALSE," + 
                                 "FOREIGN KEY (conversation_id) REFERENCES conversations(conversation_id));";
            stmt.execute(sqlMessages);



        } catch (SQLException e) {
            e.printStackTrace();
            // Gérer l'exception
        }
    }

    public static int countUnreadMessages(int userId) {
        String sql = "SELECT COUNT(*) FROM messages WHERE receiver_id = ? AND is_read = FALSE";
        int count = 0;

        try (Connection conn = getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, userId);

            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                count = rs.getInt(1);
            }

        } catch (SQLException e) {
            System.err.println("Erreur lors du comptage des messages non lus: " + e.getMessage());
        }

        return count;
    }

}
package eu.telecomnancy.labfx;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

// Description: Classe représentant une offre de matériel. Elle contient un nom, une description, une quantité, 
//              une date de début et de fin de disponibilité et un prix.
public class EquipmentOffer {
    private User owner;
    private int id;
    private String name;
    private String description;
    private int quantity;
    private LocalDate start_availability;
    private LocalDate end_availability;
    private int price;
    private String owner_mail;
    private String estPris;
    private String date_publication;
    private LocalDate book_begin;
    private LocalDate book_end;

    public EquipmentOffer(String owner_mail) {
        this.owner_mail = owner_mail;
        this.owner = new User(owner_mail);
        loadEquipmentFromDB();
    }

    public EquipmentOffer(String owner_mail, String name, String description){
        this.owner_mail = owner_mail;
        this.owner = new User(owner_mail);
        this.name = name;
        this.description = description;
        loadEquipmentFromDB();
    }

    public EquipmentOffer(String owner_mail, String name, String description, String start, String estPris){
        this.owner_mail = owner_mail;
        this.owner = new User(owner_mail);
        this.name = name;
        this.description = description;
        this.start_availability = LocalDate.parse(start);
        this.estPris = estPris;
        loadEquipmentFromDBHome();
    }

    public EquipmentOffer(String name, String description, String owner_mail, int quantity, LocalDate startAvailability, LocalDate endAvailability, int price) {
        this.owner_mail = owner_mail;
        this.owner = new User(owner_mail);
        this.name = name;
        this.description = description;
        this.quantity = quantity;
        this.start_availability = startAvailability;
        this.end_availability = endAvailability;
        this.price = price;
    }
    

    
    public EquipmentOffer(User owner, String name, String description, int quantity, LocalDate start_availability, LocalDate end_availability, int price) {
        this.owner = owner;
        this.owner_mail = owner.getMail();
        this.name = name;
        this.description = description;
        this.quantity = quantity;
        this.start_availability = start_availability;
        this.end_availability = end_availability;
        this.price = price;
        this.estPris = null;
        createNewOffer();
    }


    public void createNewOffer() {
              System.out.println("Début de la recherche des offres.création");
        String sql = "INSERT INTO equipement (owner_mail, name, description, quantity, start_availability, end_availability, price, date_publication) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
    
        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS)) {
    
            pstmt.setString(1, this.owner.getMail());
            pstmt.setString(2, this.name);
            pstmt.setString(3, this.description);
            pstmt.setInt(4, this.quantity);
            pstmt.setString(5, (this.start_availability != null) ? this.start_availability.toString() : null);
            pstmt.setString(6, (this.end_availability != null) ? this.end_availability.toString() : null);
            pstmt.setInt(7, this.price);
            pstmt.setString(8, LocalDate.now().toString());
            
            int affectedRows = pstmt.executeUpdate();
    
            // Vérifier si l'insertion a réussi et récupérer l'ID généré
            if (affectedRows > 0) {
                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        this.id = generatedKeys.getInt(1);
                    }
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Fin de la recherche des offres création.");
        }
    }

    public void loadEquipmentById(int offerId) {
        String sql = "SELECT * FROM equipement WHERE id = ?";

        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, offerId);
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                this.name = rs.getString("name");
                this.id = rs.getInt("id");
                this.description = rs.getString("description");
                this.quantity = rs.getInt("quantity");
                String start_availabilityString = rs.getString("start_availability");
                if (start_availabilityString != null && !start_availabilityString.isEmpty()) {
                    this.start_availability = LocalDate.parse(start_availabilityString);
                    } else {
                    this.start_availability = null;
                    }
                String end_availabilityString = rs.getString("end_availability");
                if (end_availabilityString != null && !end_availabilityString.isEmpty()) {
                    this.end_availability = LocalDate.parse(end_availabilityString);
                    } else {
                    this.end_availability = null;
                    }
                this.price = rs.getInt("price");
                this.date_publication = rs.getString("date_publication");
                this.estPris = rs.getString("estPris");
                String book_beginString = rs.getString("book_begin");
                if (book_beginString != null && !book_beginString.isEmpty()) {
                    this.book_begin = LocalDate.parse(book_beginString);
                    } else {
                    this.book_begin = null;
                    }
                String book_endString = rs.getString("book_end");
                if (book_endString != null && !book_endString.isEmpty()) {
                    this.book_end = LocalDate.parse(book_endString);
                    } else {
                    this.book_end = null;
                    }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    
    private void loadEquipmentFromDB() {
        String sql = "SELECT * FROM equipement WHERE owner_mail = ? AND name = ? AND description = ?";
    
        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
    
            pstmt.setString(1, this.owner.getMail());
            pstmt.setString(2, this.name);
            pstmt.setString(3, this.description);
            ResultSet rs = pstmt.executeQuery();
    
            if (rs.next()) {
                this.name = rs.getString("name");
                this.id = rs.getInt("id");
                this.description = rs.getString("description");
                this.quantity = rs.getInt("quantity");
                String start_availabilityString = rs.getString("start_availability");
                if (start_availabilityString != null && !start_availabilityString.isEmpty()) {
                    this.start_availability = LocalDate.parse(start_availabilityString);
                    } else {
                    this.start_availability = null;
                    }
                String end_availabilityString = rs.getString("end_availability");
                if (end_availabilityString != null && !end_availabilityString.isEmpty()) {
                    this.end_availability = LocalDate.parse(end_availabilityString);
                    } else {
                    this.end_availability = null;
                    }
                this.price = rs.getInt("price");
                this.date_publication = rs.getString("date_publication");
                this.estPris = rs.getString("estPris");
                String book_beginString = rs.getString("book_begin");
                if (book_beginString != null && !book_beginString.isEmpty()) {
                    this.book_begin = LocalDate.parse(book_beginString);
                    } else {
                    this.book_begin = null;
                    }
                String book_endString = rs.getString("book_end");
                if (book_endString != null && !book_endString.isEmpty()) {
                    this.book_end = LocalDate.parse(book_endString);
                    } else {
                    this.book_end = null;
                    }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void loadEquipmentFromDBHome() {
        String sql = "SELECT * FROM equipement WHERE owner_mail = ? AND name = ? AND description = ? AND start_availability = ? AND estPris IS NULL";

        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
    
            pstmt.setString(1, this.owner.getMail());
            pstmt.setString(2, this.name);
            pstmt.setString(3, this.description);
            pstmt.setString(4, this.start_availability.toString());
            ResultSet rs = pstmt.executeQuery();
    
            if (rs.next()) {
                this.name = rs.getString("name");
                this.id = rs.getInt("id");
                this.description = rs.getString("description");
                this.quantity = rs.getInt("quantity");
                String start_availabilityString = rs.getString("start_availability");
                if (start_availabilityString != null && !start_availabilityString.isEmpty()) {
                    this.start_availability = LocalDate.parse(start_availabilityString);
                    } else {
                    this.start_availability = null;
                    }
                String end_availabilityString = rs.getString("end_availability");
                if (end_availabilityString != null && !end_availabilityString.isEmpty()) {
                    this.end_availability = LocalDate.parse(end_availabilityString);
                    } else {
                    this.end_availability = null;
                    }
                this.price = rs.getInt("price");
                this.date_publication = rs.getString("date_publication");
                this.estPris = rs.getString("estPris");
                String book_beginString = rs.getString("book_begin");
                if (book_beginString != null && !book_beginString.isEmpty()) {
                    this.book_begin = LocalDate.parse(book_beginString);
                    } else {
                    this.book_begin = null;
                    }
                String book_endString = rs.getString("book_end");
                if (book_endString != null && !book_endString.isEmpty()) {
                    this.book_end = LocalDate.parse(book_endString);
                    } else {
                    this.book_end = null;
                    }
                
                // Afffichage du résultat :
                System.out.println("Offre trouvée: " + this.name + " " + this.description + " " + this.owner_mail + " " + this.quantity + " " + this.start_availability + " " + this.end_availability + " " + this.price);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public void update() {
        String sql = "UPDATE equipement SET owner_mail = ?, name = ?, description = ?, quantity = ?, start_availability = ?, end_availability = ?, price = ? WHERE id = ?";
    
        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
                
            pstmt.setString(1, this.owner.getMail());
            pstmt.setString(2, this.name);
            pstmt.setString(3, this.description);
            pstmt.setInt(4, this.quantity);
            pstmt.setString(5, (this.start_availability != null) ? this.start_availability.toString() : null);
            pstmt.setString(6, (this.end_availability != null) ? this.end_availability.toString() : null);
            pstmt.setInt(7, this.price);
            pstmt.setInt(8, this.id);
    
            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public boolean reserveOffer(EquipmentOffer offer, String currentUserEmail, LocalDate begin, LocalDate end){
        Connection conn = null;
        try {
            conn = DataBase.getConnection();
            conn.setAutoCommit(false); // Démarrer une transaction
    
            // Vérifier si l'offre est déjà réservée
            String sql = "SELECT estPris FROM equipement WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setInt(1, offer.getId());
                ResultSet rs = pstmt.executeQuery();
                if (rs.next() && rs.getString("estPris") != null) {
                    System.out.println("Cette offre a déjà été réservée");
                    conn.rollback();
                    return false;
                }
            }
    
            // Mettre à jour les florains
            if (!updateFlorains(conn, currentUserEmail, offer.getMail(), offer.getPrice())) {
                conn.rollback();
                return false;
            }
    
            // Réserver l'offre
            sql = "UPDATE equipement SET estPris = ? WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setString(1, currentUserEmail);
                pstmt.setInt(2, offer.getId());
                pstmt.executeUpdate();
            }

            // Mettre à jour les dates de réservation
            sql = "UPDATE equipement SET book_begin = ?, book_end = ? WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setString(1, begin.toString());
                pstmt.setString(2, end.toString());
                pstmt.setInt(3, offer.getId());
                pstmt.executeUpdate();
            }
            this.book_begin = begin;
            this.book_end = end;
    
            conn.commit(); // Valider la transaction
            return true;
        } catch (SQLException e) {
            e.printStackTrace();
            System.out.println("Erreur lors de la réservation de l'offre");
            if (conn != null) {
                try {
                    conn.rollback(); // Annuler la transaction en cas d'erreur
                } catch (SQLException se) {
                    se.printStackTrace();
                }
            }
            return false;
        } finally {
            if (conn != null) {
                try {
                    conn.setAutoCommit(true); // Restaurer le mode de commit automatique
                } catch (SQLException se) {
                    se.printStackTrace();
                }
            }
        }
    }

    public boolean updateFlorains(Connection conn, String buyerEmail, String sellerEmail, int price) throws SQLException {
        // Déduire les florains du compte de l'acheteur
        String sql = "UPDATE profil SET nb_florain = nb_florain - ? WHERE mail = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, price);
            pstmt.setString(2, buyerEmail);
            pstmt.executeUpdate();
        }
    
        // Ajouter les florains au compte du vendeur
        sql = "UPDATE profil SET nb_florain = nb_florain + ? WHERE mail = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, price);
            pstmt.setString(2, sellerEmail);
            pstmt.executeUpdate();
        }
    
        return true;
    }

    public static List<EquipmentOffer> searchOffers(User currentUser, String keywords, LocalDate begin, LocalDate end, Integer minPrice, Integer maxPrice, double radius) {
        System.out.println("Début de la recherche des offres avec un rayon de " + radius + " km et les mots clés " + keywords + " et les dates " + begin + " " + end + " et les prix " + minPrice + " " + maxPrice);
    
        List<EquipmentOffer> offers = new ArrayList<>();
        String sql = "SELECT owner_mail, id, name, description, quantity, start_availability, end_availability, price FROM equipement WHERE estPris IS NULL";

        if (!keywords.isEmpty()) {
            sql += " AND name LIKE ?";
        }

        if (begin != null && end != null) {
            // Les offres doivent être disponibles pour toute la période demandée
            sql += " AND (start_availability <= ? AND end_availability >= ?)";
        
        } else if (begin != null) {
            // Les offres doivent commencer au plus tard à la date de début
            sql += " AND (start_availability <= ?)";
        } else if (end != null) {
            // Les offres doivent se terminer au plus tôt à la date de fin
            sql += " AND (end_availability >= ?)";
        }

        // Logique pour le prix
        if (minPrice != null) {
            sql += " AND price >= '?' ";
        }
        if (maxPrice != null) {
            sql += " AND price <= ?";
        }

        
        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
    
            int paramIndex = 1;
            if (!keywords.isEmpty()) {
                pstmt.setString(paramIndex++, "%" + keywords + "%");
            }
            if (begin != null) {
                pstmt.setString(paramIndex++, begin.toString());
            }
            if (end != null) {
                pstmt.setString(paramIndex++, end.toString());
            }
            if (minPrice != null) {
                pstmt.setInt(paramIndex++, minPrice);
            }
            if (maxPrice != null) {
                pstmt.setInt(paramIndex++, maxPrice);
            }

    
            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    LocalDate startAvailability = rs.getString("start_availability") != null ? LocalDate.parse(rs.getString("start_availability")) : null;
                    LocalDate endAvailability = rs.getString("end_availability") != null ? LocalDate.parse(rs.getString("end_availability")) : null;
    
                    EquipmentOffer offer = new EquipmentOffer(
                        rs.getString("name"),
                        rs.getString("description"),
                        rs.getString("owner_mail"),
                        rs.getInt("quantity"),
                        startAvailability,
                        endAvailability,
                        rs.getInt("price")
                    );
                    offers.add(offer);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    
        // Filtrer les offres par rayon
        return offers.stream()
            .filter(offer -> isWithinRadius(currentUser, offer.getOwner(), radius))
            .collect(Collectors.toList());
    }
    
    
    

    private static boolean isWithinRadius(User currentUser, User offerOwner, double radius) {
        // Calcul de la distance entre l'utilisateur actuel et le propriétaire de l'offre
        double distance = currentUser.calculateDistanceTo(offerOwner);
    
        // Vérifiez si la distance est inférieure ou égale au rayon spécifié
        return distance <= radius;
    }
    
    
    
    
    

    public String getMail(){
        return owner_mail;
    }

    public User getOwner() {
        return owner;
    }

    public int getId() {
        return id;
    }
    
    public String getName() {
        return name;
    }


    public String getDescription() {
        return description;
    }


    public void setName(String name) {
        this.name = name;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public LocalDate getStartAvailability(){
        return start_availability;
    }

    public String getStartAvailabilityStr(){
        if(start_availability == null){
            return "À définir";
        }else{
            return start_availability.toString();
        }
    }

    public void setStartAvailability(LocalDate begin){
        this.start_availability = begin;
    }

    public LocalDate getEndAvaibility(){
        return end_availability;
    }

    public String getEndAvailabilityStr(){
        if(end_availability == null){
            return "À définir";
        }else{
            return end_availability.toString();
        }
    }

    public void setEndAvailability(LocalDate end){
        this.end_availability = end;
    }

    public int getPrice(){
        return price;
    }

    public void setPrice(int price){
        this.price = price;
    }

    public String getEstPris(){
        return estPris;
    }

    //set estPris
    public void setEstPris(String estPris) {
        this.estPris = estPris;
    }

    //get date_publication
    public String getDate_publication(){
        return date_publication;
    }

    //get début réservation
    public LocalDate getBook_begin(){
        return book_begin;
    }

    //get fin réservation
    public LocalDate getBook_end(){
        return book_end;
    }
}
package eu.telecomnancy.labfx;

import javafx.fxml.FXML;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;

import java.util.ArrayList;

public class HomeController {
    
    private SkeletonController skeleton_controller;

    public void setSkeletonController(SkeletonController skeleton_controller){
        this.skeleton_controller = skeleton_controller;
    }

    @FXML TableView<CombinedOffer> latest_offers;
    @FXML TableView<CombinedOffer> nearest_offers;

    private User currentUser;


    @FXML public void initialize(){
        currentUser = Main.getCurrentUser();

        // Création des colonnes
        TableColumn<CombinedOffer, String> typeColumn = new TableColumn<>("Type");
        TableColumn<CombinedOffer, String> userNameColumn = new TableColumn<>("User Name");
        TableColumn<CombinedOffer, String> titleColumn = new TableColumn<>("Title");
        TableColumn<CombinedOffer, String> priceColumn = new TableColumn<>("Price");
        TableColumn<CombinedOffer, String> datePublicationColumn = new TableColumn<>("Date Publication");
        TableColumn<CombinedOffer, String> descriptionColumn = new TableColumn<>("Description");
        TableColumn<CombinedOffer, String> cityColumn = new TableColumn<>("City");
        
        // Définir comment chaque colonne va obtenir ses valeurs
        typeColumn.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getTypeString()));
        userNameColumn.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getOwnerName()));
        titleColumn.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getTitle()));
        priceColumn.setCellValueFactory(cellData -> new SimpleStringProperty(String.valueOf(cellData.getValue().getPrice())));
        datePublicationColumn.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getDate_publication()));
        descriptionColumn.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getDescription()));
        cityColumn.setCellValueFactory(cellData -> new SimpleStringProperty(cellData.getValue().getOwner().getLocalisation()));

        // Ajoute les colonnes au TableView latest_offers
        latest_offers.getColumns().add(typeColumn);
        latest_offers.getColumns().add(userNameColumn);
        latest_offers.getColumns().add(titleColumn);
        latest_offers.getColumns().add(priceColumn);
        latest_offers.getColumns().add(datePublicationColumn);
        latest_offers.getColumns().add(descriptionColumn);
        latest_offers.getColumns().add(cityColumn);

        // Ajoute les colonnes au TableView nearest_offers
        nearest_offers.getColumns().add(typeColumn);
        nearest_offers.getColumns().add(userNameColumn);
        nearest_offers.getColumns().add(titleColumn);
        nearest_offers.getColumns().add(priceColumn);
        nearest_offers.getColumns().add(datePublicationColumn);
        nearest_offers.getColumns().add(descriptionColumn);
        nearest_offers.getColumns().add(cityColumn);

        // Ajoute les données au TableView
        ArrayList<EquipmentOffer> all_equipment = Main.getAllEquipment();
        ArrayList<ServiceOffer> all_service = Main.getAllService();
    
        ArrayList<CombinedOffer> all_offers = new ArrayList<>();
    
        // Ajouter les offres d'équipement après les avoir filtrées
        if(all_equipment != null){
            for(EquipmentOffer equipment : all_equipment){
                if(equipment.getOwner().getEtatCompte().equals("actif")){all_offers.add(new CombinedOffer(equipment));}
            }
        }
    
        // Ajouter les offres de service après les avoir filtrées
        if(all_service != null){
            for(ServiceOffer service : all_service){
                if(service.getSupplier().getEtatCompte().equals("actif")){all_offers.add(new CombinedOffer(service));}
            }
        }
    
        // Trier et afficher les offres
        // Trier par date de publication
        all_offers.sort((o1, o2) -> o2.getDate_publication().compareTo(o1.getDate_publication()));
        if(all_offers != null){
            latest_offers.setItems(FXCollections.observableArrayList(all_offers));
        }

        // Trier par distance
        all_offers.sort((o1, o2) -> {
            double distance1 = currentUser.calculateDistanceTo(o1.getOwner());
            double distance2 = currentUser.calculateDistanceTo(o2.getOwner());
                 
            return Double.compare(distance1, distance2);
        });
        if(all_offers != null){
            nearest_offers.setItems(FXCollections.observableArrayList(all_offers));
        }

        latest_offers.setOnMouseClicked(event -> {
            if (event.getClickCount() == 2 && !latest_offers.getSelectionModel().isEmpty()) {
                CombinedOffer selected_item = latest_offers.getSelectionModel().getSelectedItem();
                handleDoubleClickOnEquipment(selected_item);
            }
        });
    }

    private void handleDoubleClickOnEquipment(CombinedOffer item) {
        // Ici, tu peux effectuer une action avec l'objet ServiceOffer sélectionné
        if(item.getTypeString().equals("Equipment")){
            EquipmentOffer equipment = new EquipmentOffer(item.getOwner().getMail(), item.getTitle(), item.getDescription(), item.getStartString(), item.getEstPris());
            skeleton_controller.loadEquipmentOfferPage(equipment);
        }else{
            ServiceOffer service = new ServiceOffer(item.getOwner().getMail(), item.getTitle(), item.getDescription(), item.getStartString(), item.getEstPris());
            skeleton_controller.loadServiceOfferPage(service);
        }
    }

    @FXML public void handleDeconnexion(){
        System.out.println("Deconnexion de la session");
        skeleton_controller.main_controller.loadWelcomePage();
    }
    
}
package eu.telecomnancy.labfx;

import java.io.IOException;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import java.sql.SQLException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;


public class Main extends Application {

    private static Stage primaryStage;
    private static User currentUser;

    public static User getCurrentUser() {
        return currentUser;
    }

    public static void setCurrentUser(User currentUser) {
        Main.currentUser = currentUser;
    }

    public static Stage getPrimaryStage() {
        return primaryStage;
    }

    public static void setPrimaryStage(Stage stage) {
        primaryStage = stage;
    }

    public static ArrayList<ServiceOffer> getAllService() {
        String sql = "SELECT supplier_mail, title, description, estPris FROM service_offers";

        try (Connection conn = DataBase.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            ResultSet rs = pstmt.executeQuery();
            ArrayList<ServiceOffer> all_service = new ArrayList<>();

            while (rs.next()) {
                if(rs.getString("estPris") != null){
                    continue;
                }
                String supplierMail = rs.getString("supplier_mail");
                String title = rs.getString("title");
                String description = rs.getString("description");

                ServiceOffer service = new ServiceOffer(supplierMail, title, description);
                all_service.add(service);
            }

            return all_service;
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            return null;
        }
    }

    public static ArrayList<ServiceOffer> getAllServiceHome() {
        String sql = "SELECT supplier_mail, title, description, start, estPris FROM service_offers";

        try (Connection conn = DataBase.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            ResultSet rs = pstmt.executeQuery();
            ArrayList<ServiceOffer> all_service = new ArrayList<>();

            while (rs.next()) {
                if(rs.getString("estPris") != null){
                    continue;
                }
                String supplierMail = rs.getString("supplier_mail");
                String title = rs.getString("title");
                String description = rs.getString("description");
                String start = rs.getString("start");

                ServiceOffer service = new ServiceOffer(supplierMail, title, description, start, null);
                all_service.add(service);
            }

            return all_service;
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            return null;
        }
    }

    public static ArrayList<EquipmentOffer> getAllEquipment() {
        String sql = "SELECT owner_mail, name, description, estPris FROM equipement";

        try (Connection conn = DataBase.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            ResultSet rs = pstmt.executeQuery();
            ArrayList<EquipmentOffer> all_equipment = new ArrayList<>();

            while (rs.next()) {
                if(rs.getString("estPris") != null){
                    continue;
                }
                String owner_mail = rs.getString("owner_mail");
                String name = rs.getString("name");
                String description = rs.getString("description");

                EquipmentOffer equipment = new EquipmentOffer(owner_mail, name, description);
                all_equipment.add(equipment);
            }
            
            return all_equipment;
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            return null;
        }
    }

    public static ArrayList<EquipmentOffer> getAllEquipmentHome() {
        String sql = "SELECT owner_mail, name, description, start_availability, estPris FROM equipement";

        try (Connection conn = DataBase.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            ResultSet rs = pstmt.executeQuery();
            ArrayList<EquipmentOffer> all_equipment = new ArrayList<>();

            while (rs.next()) {
                if(rs.getString("estPris") != null){
                    continue;
                }
                String owner_mail = rs.getString("owner_mail");
                String name = rs.getString("name");
                String description = rs.getString("description");
                String start_availability = rs.getString("start_availability");

                EquipmentOffer equipment = new EquipmentOffer(owner_mail, name, description, start_availability, null);
                all_equipment.add(equipment);
            }
            
            return all_equipment;
        } catch (SQLException e) {
            System.out.println(e.getMessage());
            return null;
        }
    }

    public static void main(String[] args) {
        DataBase.initializeDatabase();
        Application.launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws IOException {
        setPrimaryStage(primaryStage);
        primaryStage.setTitle("DirectDealing");
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/WelcomePage.fxml"));
        Parent root = loader.load();
        
        Scene scene = new Scene(root, 1600, 900);
        primaryStage.setScene(scene);
        primaryStage.setResizable(true);
        primaryStage.show();
    }
}
package eu.telecomnancy.labfx;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import java.io.IOException;

public class MainController {

    

    @FXML private TextField emailField;
    @FXML private PasswordField passwordField;
    @FXML private SkeletonController skeleton_controller;

    private static User currentUser;

    public void initialize(){
        System.out.println("Initialisation de la session");
        currentUser = Main.getCurrentUser();
    }

    // Fonction qui permet de charger la page de bienvenue
    public void loadWelcomePage() {
        System.out.println("Chargement de la page de bienvenue");
        try {
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/WelcomePage.fxml"));
            Parent welcomePage = loader.load();

            // Ajouter le WelcomePage à la scène
            Main.getPrimaryStage().getScene().setRoot(welcomePage);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    // Fonction qui permet de charger la page d'inscription
    public void loadInscriptionPage() {
        try {
            System.out.println("Chargement de la page d'inscription");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/InscriptionPage.fxml"));
            Parent inscription = loader.load();

            InscriptionController inscriptionController = loader.getController();
            inscriptionController.setMainController(this);

            // Ajouter la page d'inscription à la scène
            Main.getPrimaryStage().getScene().setRoot(inscription);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    // Fonction qui charge le squellete de la page d'accueil
    public void loadSkeleton() {
        
        try {
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/SkeletonPage.fxml"));
            Parent skeletonPage = loader.load();
            SkeletonController skeleton_controller = loader.getController();
            skeleton_controller.setMainController(this);
            Main.getPrimaryStage().getScene().setRoot(skeletonPage);
            setSkeletonController(skeleton_controller);

            skeleton_controller.loadMenuPage();
            skeleton_controller.loadProfilePage();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void loadHomePage() {
        loadSkeleton();
        skeleton_controller.loadHomePage();
    }

    public void loadServicePage(){
        loadSkeleton();
        skeleton_controller.loadServicePage();
    }


    // Bouton qui charge la page d'incription
    @FXML
    public void handleInscription() throws IOException {
        loadInscriptionPage();
    }

    // Bouton qui charge la page de bienvenue
    @FXML
    public void handleWelcome() throws IOException {
        loadWelcomePage();
    }



    // Bouton qui tente la connexion
    @FXML
    private void handleConnexion() {
        String email = emailField.getText();
        String password = passwordField.getText();
        try (Connection conn = DataBase.getConnection()) {
            String sql = "SELECT * FROM profil WHERE mail = ? AND password = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setString(1, email);
                pstmt.setString(2, password);
                ResultSet rs = pstmt.executeQuery();

                if (rs.next()) {
                    // Utilisateur trouvé, rediriger vers Dashboard.fxml
                    System.out.println("Utilisateur trouvé, Connexion réussie");

                    // Creation d'un objet User
                    User user = new User(email);
                    currentUser = user;
                    Main.setCurrentUser(currentUser);
                    System.out.println("Prenom: " + user.getPrenom() + " Nom: " + user.getNom() + " Pseudo: " + user.getPseudo() + " Mail: " + user.getMail() + " Phone: " + user.getPhone() + " Photo de profil: " + user.getPhotoProfil() + " Localisation: " + user.getLocalisation() + " Date d'inscription: " + user.getDateInscription() + " Status du compte: " + user.getStatusCompte() + " Etat du compte: " + user.getEtatCompte() + " Nombre de florain: " + user.getNbFlorain() + " Historique florain: " + user.getHistoriqueFlorain() + " Note: " + user.getNote());
                    // Charger la page d'accueil
                    loadHomePage();
                } else {
                    System.out.println("Identifiants incorrects");
                    // Afficher un message d'erreur
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
            // Gestion des erreurs SQL
        }
    }

    //Fonction qui permet de définir le skeleton controller
    public void setSkeletonController(SkeletonController skeleton_controller) {
        this.skeleton_controller = skeleton_controller;
    }


    
}

package eu.telecomnancy.labfx;

import eu.telecomnancy.labfx.messagerie.Conversation;
import eu.telecomnancy.labfx.messagerie.Message;
import java.util.Map;
import java.util.HashMap;


import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.time.LocalDateTime;
import java.sql.Timestamp;
import java.util.Comparator;


package eu.telecomnancy.labfx;


import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.*;
import java.util.stream.Collectors;


// Description: Classe représentant une offre de service. Elle contient un titre, une description, une date et une heure.
//              Elle peut être récurrente, auquel cas on lui ajoute un tableau de jours de la semaine où le service doit être réalisé.$

public class ServiceOffer {
    private int id;
    private User supplier;
    private String title;
    private String description;
    private LocalDate start;
    private LocalDate end;
    private LocalTime time;
    private boolean isRecurrent;
    private String daysOfService; // Stocké comme une chaîne, par exemple "1,3,5"
    private int nbRecurrencingWeeks;
    private String supplier_mail;
    private int price;
    private String estPris;
    private String date_publication;
    private LocalDate book_begin;
    private LocalDate book_end;

    // Constructeur
    public ServiceOffer(String supplier_mail) {
        this.supplier_mail = supplier_mail;
        this.supplier = new User(supplier_mail);
        System.out.println("Constructeur avec un loaddb 1");
        loadServiceFromDB();
    }

    public ServiceOffer(String supplierMail, String title, String description, LocalDate start, LocalDate end, LocalTime time, int price) {
        System.out.println("Constructeur avec un loaddb 2 ");
        this.supplier_mail = supplierMail;
        this.supplier = new User(supplierMail);
        this.title = title;
        this.description = description;
        this.start = start;
        this.end = end;
        this.time = time;
        this.price = price;
        createNewOffer();
    }

       public ServiceOffer(String supplier_mail, String title, String description, LocalDate start, LocalDate end, LocalTime time, int price, String estPris){
                System.out.println("Constructeur sans un loaddb 5 ");
        this.supplier_mail = supplier_mail;
        this.supplier = new User(supplier_mail);
        this.title = title;
        this.description = description;
        this.start = start;
        this.end = end;
        this.time = time;
        this.price = price;
    }


    public ServiceOffer(String supplier_mail, String title, String description){
                System.out.println("Constructeur avec un loaddb 3");
        this.supplier_mail = supplier_mail;
        this.supplier = new User(supplier_mail);
        this.title = title;
        this.description = description;
        loadServiceFromDB();
    }

    public ServiceOffer(String supplier_mail, String title, String description, String start, String estPris){
        System.out.println("Constructeur avec un loaddb 4");
        this.supplier_mail = supplier_mail;
        this.supplier = new User(supplier_mail);
        this.title = title;
        this.description = description;
        this.start = LocalDate.parse(start);
        this.estPris = estPris;
        loadServiceFromDBHome();
    }

 

    public ServiceOffer(User supplier, String title, String description, LocalDate start, LocalDate end, LocalTime time, boolean isRecurrent, String daysOfService, int price) {
        System.out.println("Constructeur avec un loaddb 6");
        this.supplier = supplier;
        this.supplier_mail = supplier.getMail();
        this.title = title;
        this.description = description;
        this.start = start;
        this.end = end;
        this.time = time;
        this.isRecurrent = isRecurrent;
        this.daysOfService = daysOfService;
        this.price = price;
        this.estPris = null;
        if (isRecurrent) {
            String[] days = daysOfService.split(",");
            this.nbRecurrencingWeeks = days.length;
        } else {
            this.nbRecurrencingWeeks = 0;
        }
        createNewOffer();
    }




    public void createNewOffer(){
        String sql = "INSERT INTO service_offers (supplier_mail, title, description, start, end, time, is_recurrent, days_of_service, price, date_publication) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS)) {
    
            pstmt.setString(1, this.supplier.getMail());
            pstmt.setString(2, this.title);
            pstmt.setString(3, this.description);
            pstmt.setString(4, (this.start != null) ? this.start.toString() : null);
            pstmt.setString(5, (this.end != null) ? this.end.toString() : null);
            pstmt.setString(6, (this.time != null) ? this.time.toString() : null);
            pstmt.setBoolean(7, this.isRecurrent);
            pstmt.setString(8, this.daysOfService);
            pstmt.setInt(9, this.price);
            pstmt.setString(10, LocalDate.now().toString());
    
            int affectedRows = pstmt.executeUpdate();
    
            // Vérifier si l'insertion a réussi et récupérer l'ID généré
            if (affectedRows > 0) {
                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        this.id = generatedKeys.getInt(1);
                    }
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    private void loadServiceFromDB() {
        String sql = "SELECT * FROM service_offers WHERE supplier_mail = ? AND title = ? AND description = ?";

        try (Connection conn = DataBase.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, supplier_mail);
            pstmt.setString(2, title); // Assure-toi que la variable 'title' est définie et contient le titre à vérifier
            pstmt.setString(3, description); // Assure-toi que la variable 'description' est définie et contient la description à vérifier
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                this.id = rs.getInt("id");
                this.title = rs.getString("title");
                this.description = rs.getString("description");
                String startDateString = rs.getString("start");
                if (startDateString != null && !startDateString.isEmpty()) {
                    this.start = LocalDate.parse(startDateString);
                    } else {
                    this.start = null;
                    }
                String endDateString = rs.getString("end");
                if (endDateString != null && !endDateString.isEmpty()) {
                    this.end = LocalDate.parse(endDateString);
                    } else {
                    this.end = null;
                    }
                String timeString = rs.getString("time");
                if (timeString != null && !timeString.isEmpty()) {
                    this.time = LocalTime.parse(timeString);
                    } else {
                    this.time = null;
                    }
                this.isRecurrent = rs.getBoolean("is_recurrent");
                this.daysOfService = rs.getString("days_of_service");
                this.price = rs.getInt("price");
                this.date_publication = rs.getString("date_publication");
                this.estPris = rs.getString("estPris");
                String bookingBeginString = rs.getString("book_begin");
                if (bookingBeginString != null && !bookingBeginString.isEmpty()) {
                    this.book_begin = LocalDate.parse(bookingBeginString);
                    } else {
                    this.book_begin = null;
                    }
                String bookingEndString = rs.getString("book_end");
                if (bookingEndString != null && !bookingEndString.isEmpty()) {
                    this.book_end = LocalDate.parse(bookingEndString);
                    } else {
                    this.book_end = null;
                    }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void loadServiceFromDBHome() {
        String sql = "SELECT * FROM service_offers WHERE supplier_mail = ? AND title = ? AND description = ? AND start = ? AND estPris IS NULL";

        try (Connection conn = DataBase.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, supplier_mail);
            pstmt.setString(2, title); // Assure-toi que la variable 'title' est définie et contient le titre à vérifier
            pstmt.setString(3, description); // Assure-toi que la variable 'description' est définie et contient la description à vérifier
            pstmt.setString(4, this.start.toString());
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                this.id = rs.getInt("id");
                this.title = rs.getString("title");
                this.description = rs.getString("description");
                String startDateString = rs.getString("start");
                if (startDateString != null && !startDateString.isEmpty()) {
                    this.start = LocalDate.parse(startDateString);
                    } else {
                    this.start = null;
                    }
                String endDateString = rs.getString("end");
                if (endDateString != null && !endDateString.isEmpty()) {
                    this.end = LocalDate.parse(endDateString);
                    } else {
                    this.end = null;
                    }
                String timeString = rs.getString("time");
                if (timeString != null && !timeString.isEmpty()) {
                    this.time = LocalTime.parse(timeString);
                    } else {
                    this.time = null;
                    }
                this.isRecurrent = rs.getBoolean("is_recurrent");
                this.daysOfService = rs.getString("days_of_service");
                this.price = rs.getInt("price");
                this.date_publication = rs.getString("date_publication");
                this.estPris = rs.getString("estPris");
                String bookingBeginString = rs.getString("book_begin");
                if (bookingBeginString != null && !bookingBeginString.isEmpty()) {
                    this.book_begin = LocalDate.parse(bookingBeginString);
                    } else {
                    this.book_begin = null;
                    }
                String bookingEndString = rs.getString("book_end");
                if (bookingEndString != null && !bookingEndString.isEmpty()) {
                    this.book_end = LocalDate.parse(bookingEndString);
                    } else {
                    this.book_end = null;
                    }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void update() {
        String sql = "UPDATE service_offers SET supplier_mail = ?, title = ?, description = ?, start = ?, end = ?, time = ?, is_recurrent = ?, days_of_service = ?, price = ?, WHERE id = ?";
    
        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
    
            pstmt.setString(1, this.supplier.getMail());
            pstmt.setString(2, this.title);
            pstmt.setString(3, this.description);
            pstmt.setString(4, (this.start != null) ? this.start.toString() : null);
            pstmt.setString(5, (this.end != null) ? this.end.toString() : null);
            pstmt.setString(6, (this.time != null) ? this.time.toString() : null);
            pstmt.setBoolean(7, this.isRecurrent);
            pstmt.setString(8, this.daysOfService);
            pstmt.setInt(9, this.nbRecurrencingWeeks);
            pstmt.setInt(10, this.id);
    
            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    

    public boolean reserveOffer(ServiceOffer offer, String currentUserEmail, LocalDate begin, LocalDate end) {
        Connection conn = null;
        try {
            conn = DataBase.getConnection();
            conn.setAutoCommit(false); // Démarrer une transaction
    
            // Vérifier si l'offre est déjà réservée
            String sql = "SELECT estPris FROM service_offers WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setInt(1, offer.getId());
                ResultSet rs = pstmt.executeQuery();
                if (rs.next() && rs.getString("estPris") != null) {
                    System.out.println("Cette offre a déjà été réservée");
                    conn.rollback();
                    return false;
                }
            }
    
            // Mettre à jour les florains
            if (!updateFlorains(conn, currentUserEmail, offer.getSupplierMail(), offer.getPrice())) {
                conn.rollback();
                return false;
            }
    
            // Réserver l'offre
            sql = "UPDATE service_offers SET estPris = ? WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setString(1, currentUserEmail);
                pstmt.setInt(2, offer.getId());
                pstmt.executeUpdate();
            }
    
            // Ajouter les dates de réservation
            sql = "UPDATE service_offers SET book_begin = ?, book_end = ? WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setString(1, begin.toString());
                pstmt.setString(2, end.toString());
                pstmt.setInt(3, offer.getId());
                pstmt.executeUpdate();
            }
            this.book_begin = begin;
            this.book_end = end;

            conn.commit(); // Valider la transaction
            return true;
        } catch (SQLException e) {
            e.printStackTrace();
            System.out.println("Erreur lors de la réservation de l'offre");
            if (conn != null) {
                try {
                    conn.rollback(); // Annuler la transaction en cas d'erreur
                } catch (SQLException se) {
                    se.printStackTrace();
                }
            }
            return false;
        } finally {
            if (conn != null) {
                try {
                    conn.setAutoCommit(true); // Restaurer le mode de commit automatique
                } catch (SQLException se) {
                    se.printStackTrace();
                }
            }
        }
    }

    public boolean updateFlorains(Connection conn, String buyerEmail, String sellerEmail, int price) throws SQLException {
        // Déduire les florains du compte de l'acheteur
        String sql = "UPDATE profil SET nb_florain = nb_florain - ? WHERE mail = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, price);
            pstmt.setString(2, buyerEmail);
            pstmt.executeUpdate();
        }
    
        // Ajouter les florains au compte du vendeur
        sql = "UPDATE profil SET nb_florain = nb_florain + ? WHERE mail = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, price);
            pstmt.setString(2, sellerEmail);
            pstmt.executeUpdate();
        }
    
        return true;
    }
    public static List<ServiceOffer> searchOffers(User currentUser, String keywords, LocalDate begin, LocalDate end, Integer minPrice, Integer maxPrice, String timeMin, String timeMax, double radius) {
        System.out.println("Début de la recherche des offres avec un rayon de " + radius + " km et les mots clés " + keywords + " et les dates " + begin + " " + end + " et les prix " + minPrice + " " + maxPrice);
    
        List<ServiceOffer> offers = new ArrayList<>();
    
        // Construction de la requête SQL avec les filtres nécessaires
        String sql = "SELECT id, supplier_mail, title, description, start, end, time, price, estPris FROM service_offers WHERE estPris IS NULL";
    
        if (!keywords.isEmpty()) {
            sql += " AND title LIKE ?";
        }
        if (begin != null && end != null) {
            // Les offres doivent être disponibles pour toute la période demandée
            sql += " AND (start <= ? AND end >= ?)";
        
        } else if (begin != null) {
            // Les offres doivent commencer au plus tard à la date de début
            sql += " AND (start <= ?)";
        } else if (end != null) {
            // Les offres doivent se terminer au plus tôt à la date de fin
            sql += " AND (end >= ?)";
        }
        if (minPrice != null) {
            sql += " AND price >= ?";
        }
        if (maxPrice != null) {
            sql += " AND price <= ?";
        }
        if (!timeMin.isEmpty()) {
            sql += " AND time >= ?";
        }
        if (!timeMax.isEmpty()) {
            sql += " AND time <= ?";
        }
    
        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
    
            int paramIndex = 1;
    
            if (!keywords.isEmpty()) {
                pstmt.setString(paramIndex++, "%" + keywords + "%");
            }
            if (begin != null) {
                pstmt.setString(paramIndex++, begin.toString());
            }
            if (end != null) {
                pstmt.setString(paramIndex++, end.toString());
            }
            if (minPrice != null) {
                pstmt.setInt(paramIndex++, minPrice);
            }
            if (maxPrice != null) {
                pstmt.setInt(paramIndex++, maxPrice);
            }
            if (!timeMin.isEmpty()) {
                pstmt.setString(paramIndex++, timeMin);
            }
            if (!timeMax.isEmpty()) {
                pstmt.setString(paramIndex++, timeMax);
            }
    
            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    LocalDate serviceStart = rs.getString("start") != null ? LocalDate.parse(rs.getString("start")) : null;
                    LocalDate serviceEnd = rs.getString("end") != null ? LocalDate.parse(rs.getString("end")) : null;
                    LocalTime time = rs.getString("time") != null ? LocalTime.parse(rs.getString("time")) : null;
    
                    ServiceOffer offer = new ServiceOffer(
                        rs.getString("supplier_mail"),
                        rs.getString("title"),
                        rs.getString("description"),
                        serviceStart,
                        serviceEnd,
                        time,
                        rs.getInt("price"),
                        rs.getString("estPris")


                    );
                    offers.add(offer);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        for (ServiceOffer offer : offers) {
            System.out.println("id: " + offer.getId() + " title: " + offer.getTitle() + " description: " + offer.getDescription() + " start: " + offer.getStart() + " end: " + offer.getEnd() + " time: " + offer.getTime() + " isRecurrent: " + offer.getIsRecurrent() + " repetitionDay: " + offer.getDaysOfService() + " price: " + offer.getPrice() + " nb recurrence: " + offer.getRecurrency() + " supplier mail: " + offer.getSupplierMail() + " est pris: " + offer.getEstPris());
        }
// Filtrer les offres par rayon
        return offers.stream()
            .filter(offer -> isWithinRadius(currentUser, offer.getSupplier(), radius))
            .collect(Collectors.toList());
 
    }

    private static boolean isWithinRadius(User currentUser, User offerOwner, double radius) {
        // Calcul de la distance entre l'utilisateur actuel et le propriétaire de l'offre
        double distance = currentUser.calculateDistanceTo(offerOwner);
    
        // Vérifiez si la distance est inférieure ou égale au rayon spécifié
        return distance <= radius;
    }
    
    
    
    

    public String getSupplierMail(){
        return supplier_mail;
    }

    public User getSupplier(){
        return supplier;
    }

    public int getId(){
        return id;
    }

    public String getTitle(){
        return title;
    }

    public void setTitle(String title){
        this.title = title;
    }

    public String getDescription(){
        return description;
    }

    public void setDescription(String description){
        this.description = description;
    }

    public LocalDate getStart(){
        return start;
    }

    public String getStartStr(){
        if(start == null){
            return "À définir";
        }else{
            return start.toString();
        }
    }

    public void setStart(LocalDate start){
        this.start = start;
    }

    public LocalDate getEnd(){
        return end;
    }

    public String getEndStr(){
        if(end == null){
            return "À définir";
        }else{
            return end.toString();
        }
    }

    public void setEnd(LocalDate end){
        this.end = end;
    }

    public LocalTime getTime(){
        return time;
    }

    public String getTimeStr(){
        if(time == null){
            return "À définir";
        }else{
            return time.toString();
        }
    }

    public void setTime(LocalTime time){
        this.time = time;
    }

    public void setRecurrent(boolean isRecurrent) {
        this.isRecurrent = isRecurrent;
    }

    public void setDaysOfService(String daysOfService) {
        this.daysOfService = daysOfService;
    }


    public boolean getIsRecurrent() {
        return isRecurrent;
    }

    public String getDaysOfService() {
        return daysOfService;
    }

    public int getRecurrency() {
        return nbRecurrencingWeeks;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public void setNbRecurrencingWeeks(String daysOfService) {
        if (this.isRecurrent) {
            String[] days = daysOfService.split(",");
            this.nbRecurrencingWeeks = days.length;
        } else {
            this.nbRecurrencingWeeks = 0;
        }
    }

    //get estPris
    public String getEstPris(){
        return estPris;
    }

    //set estPris
    public void setEstPris(String estPris) {
        this.estPris = estPris;
    }

    //get date_publication
    public String getDate_publication(){
        return date_publication;
    }

    //get book_begin
    public LocalDate getBook_begin(){
        return book_begin;
    }

    //get book_end
    public LocalDate getBook_end(){
        return book_end;
    }

}

package eu.telecomnancy.labfx;

import javafx.fxml.FXML;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.DatePicker;
import java.time.LocalDate;

public class ServiceOfferController {

    private SkeletonController skeleton_controller;
    private ServiceOffer service_offer;
    private User currentUser;

    public void setSkeletonController(SkeletonController skeleton_controller){
        this.skeleton_controller = skeleton_controller;
    }

    @FXML private Label title;
    @FXML private Label description;
    @FXML private Label date;
    @FXML private Label price;

    @FXML private Button book;
    @FXML private Button cancel;
    @FXML private Button contact;

    @FXML private DatePicker booking_begin;
    @FXML private DatePicker booking_end;

    public void setCurrentOffer(ServiceOffer offer) {
        this.service_offer = offer;
        currentUser = Main.getCurrentUser();
        displayOfferInfo();
    }

    private void displayOfferInfo() {
        title.setText("Titre : " + service_offer.getTitle());
        description.setText("Description : " + service_offer.getDescription());
        String startDateString = service_offer.getStart() != null ? service_offer.getStart().toString() : "Pas de date renseigné";
        String endDateString = service_offer.getEnd() != null ? service_offer.getEnd().toString() : "Pas de date renseigné";
        String time = service_offer.getTime() != null ? service_offer.getTime().toString() : "Pas d'heure renseigné";
        date.setText("Date : " + startDateString + " to " + endDateString + " at " + time);
        price.setText("Coût en florains : " + service_offer.getPrice());

        if (service_offer.getSupplierMail().equals(currentUser.getMail())){
            book.setVisible(false);
            booking_begin.setVisible(false);
            booking_end.setVisible(false);
            contact.setVisible(false);
        }

    }

    @FXML public void handleBook() {
        System.out.println("Tentative de réservation de l'offre");
        
        // Obtenir l'email de l'utilisateur actuel
        String currentUserEmail = Main.getCurrentUser().getMail();
    
        // Vérifier que l'utilisateur actuel n'est pas le fournisseur de l'offre
        if (currentUserEmail.equals(service_offer.getSupplierMail())) {
            System.out.println("Vous ne pouvez pas réserver votre propre offre");
            return;
        }
    
        // Vérifier qu'un utilisateur n'a pas déjà réservé l'offre
        if (service_offer.getEstPris() != null) {
            System.out.println("Cette offre a déjà été réservée");
            return;
        }

        LocalDate begin = booking_begin.getValue();
        LocalDate end = booking_end.getValue();

        if(begin == null || end == null){
            System.out.println("Veuillez renseigner une date de début et de fin");
            return;
        }else if(begin.isAfter(end)){
            System.out.println("La date de début doit être avant la date de fin");
            return;
        }else if(begin.isBefore(service_offer.getStart()) || end.isAfter(service_offer.getStart())){
            System.out.println("La date de début et de fin doivent être comprises dans la période de disponibilité de l'offre");
            return;
        }


        // Tenter de réserver l'offre
        if (service_offer.reserveOffer(service_offer, currentUserEmail, begin, end)) {
            System.out.println("Offre réservée avec succès");

            // Création de deux nouvelles offres avant et après la période de réservation
            // si le premier jour de réservation est le même que le début de l'offre de base, on en crée qu'une après
            // inverse pour le dernier jour de réservation
            /* if(begin.equals(service_offer.getStart()) && end.equals(service_offer.getEnd())){
                System.out.println("Offre bien créée");
            }else if(begin.equals(service_offer.getStart())){
                System.out.println("Offre bien créée");
                ServiceOffer newOffer = new ServiceOffer(); */



            service_offer.setEstPris(currentUserEmail);
            //set nb florain user
            currentUser = Main.getCurrentUser();
            currentUser.setNbFlorain(currentUser.getNbFlorain() - service_offer.getPrice());
            skeleton_controller.updateProfile();
  
            skeleton_controller.loadListServiceOfferPage();
   
        } else {
            System.out.println("La réservation de l'offre a échoué");
        }
    }
    

    @FXML public void handleContact() {
        System.out.println("Lancement d'une conversation avec le propriétaire de l'offre");
    
        // Obtenir le pseudo du fournisseur
        String supplierPseudo = service_offer.getSupplier().getPseudo();
    
        // Passer le pseudo du fournisseur au SkeletonController
        skeleton_controller.setSupplierForMessaging(supplierPseudo);
    
        // Charger la page de messagerie
        skeleton_controller.loadMessageriePage();
    }

    @FXML public void cancel(){
        System.out.println("Go back !");
        skeleton_controller.loadListServiceOfferPage();
    }
}
package eu.telecomnancy.labfx;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.layout.VBox;
import javafx.scene.Parent;
import javafx.scene.control.SplitPane;
import java.util.ArrayList;
import java.io.IOException;

public class SkeletonController {

    public MainController main_controller;
    private User currentUser;
    private String supplierForMessaging;

    public void setMainController(MainController main_controller) {
        this.main_controller = main_controller;
    }
    public void setSupplierForMessaging(String pseudo) {
        this.supplierForMessaging = pseudo;
    }

    @FXML private SplitPane skeletonContent;

    @FXML private VBox menuContent;

    @FXML private ProfileController profil_controller;

    @FXML private VBox profileContent;

    @FXML private VBox mainContent;




    public void initialize(){
        System.out.println("Initialisation de la session");
        currentUser = Main.getCurrentUser();
    }

    public void setProfileController(ProfileController profil_controller){
        this.profil_controller = profil_controller;
    }

    // Vous pouvez également ajouter des méthodes spécifiques pour charger le menu et le profil si nécessaire
    public void loadMenuPage() {
        try {
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/Menu.fxml"));
            Parent menu_page = loader.load();

            MenuController menu_controller = loader.getController();
            menu_controller.setSkeletonController(this);

            menuContent.getChildren().setAll(menu_page);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void loadProfilePage() {
        try {
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/Profile.fxml"));
            Parent profil_page = loader.load();

            ProfileController profile_controller = loader.getController();
            profile_controller.setSkeletonController(this);
            setProfileController(profile_controller);
            profileContent.getChildren().setAll(profil_page);
            

        } catch (IOException e) {
            e.printStackTrace();
        }
    }



    // Fonction qui permet de charger la home page:
    public void loadHomePage(){
        try {
            System.out.println("Chargement de la page Home");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/HomePage.fxml"));
            Parent home = loader.load();

            HomeController home_controller = loader.getController();
            home_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(home);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    // Fonction qui permet de charger la page des services
    public void loadServicePage(){
        try {
            System.out.println("Chargement de la page Service");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/Service.fxml"));
            Parent service = loader.load();

            ServiceController service_controller = loader.getController();
            service_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(service);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void loadEquipmentPage(){
        try {
            System.out.println("Chargement de la page matériel");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/Equipment.fxml"));
            Parent equipment = loader.load();

            EquipmentController equipment_controller = loader.getController();
            equipment_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(equipment);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page de création des équipements
    public void loadCreateEquipmentPage(){
        try {
            System.out.println("Chargement de la page de création d'une offre d'équipement");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/CreateEquipment.fxml"));
            Parent create_equipment = loader.load();

            CreateEquipmentController create_equipment_controller = loader.getController();
            create_equipment_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(create_equipment);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public void loadEquipmentOfferPage(EquipmentOffer offer){
        try {
            System.out.println("Chargement de la page d'une offre d'équipement");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/EquipmentOffer.fxml"));
            Parent equipment_offer = loader.load();

            EquipmentOfferController equipment_offer_controller = loader.getController();
            equipment_offer_controller.setSkeletonController(this);
            equipment_offer_controller.setCurrentOffer(offer);


            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(equipment_offer);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page de liste des offres d'équipement
    public void loadListEquipmentOfferPage(){
        try {
            System.out.println("Chargement de la page de liste des offres d'équipement");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/ConsultEquipment.fxml"));
            Parent list_equipment_offer = loader.load();

            ConsultEquipmentController list_equipment_offer_controller = loader.getController();
            list_equipment_offer_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(list_equipment_offer);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page de liste des offres de service
    public void loadListServiceOfferPage(){
        try {
            System.out.println("Chargement de la page de liste des offres de service");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/ConsultService.fxml"));
            Parent list_service_offer = loader.load();

            ConsultServiceController list_service_offer_controller = loader.getController();
            list_service_offer_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(list_service_offer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    // Fonction qui permet de charger la page de profile privé
    public void loadPrivateProfile() {
        try {
            System.out.println("Chargement de la page de profile privé");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/PrivateProfilePage.fxml"));
            Parent privateProfile = loader.load();

            PrivateProfileController privateProfile_controller = loader.getController();
            privateProfile_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(privateProfile);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page d'affichage d'une offre de service
    public void loadServiceOfferPage(ServiceOffer offer){
        try {
            System.out.println("Chargement de la page d'une offre de service");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/ServiceOffer.fxml"));
            Parent service_offer = loader.load();
            ServiceOfferController service_offer_controller = loader.getController();
            service_offer_controller.setSkeletonController(this);
            service_offer_controller.setCurrentOffer(offer);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(service_offer);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page de création d'une offre de service
    public void loadCreateServicePage(){
        try {
            System.out.println("Chargement de la page de création d'une offre de service");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/CreateService.fxml"));
            Parent create_service = loader.load();

            CreateServiceController create_service_controller = loader.getController();
            create_service_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(create_service);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page de la carte
    public void loadMapPage(){
        try {
            System.out.println("Chargement de la Map page");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/Map.fxml"));
            Parent map = loader.load();

            MapController map_controller = loader.getController();
            map_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(map);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page du planning
    public void loadPlanningPage(){
        try {
            System.out.println("Chargement de la page planning");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/Planning.fxml"));
            Parent planning = loader.load();

            PlanningController planning_controller = loader.getController();
            planning_controller.setSkeletonController(this);

            // Ajouter la page d'inscription à la scène
            mainContent.getChildren().setAll(planning);
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Fonction qui permet de charger la page de la messagerie
    public void loadMessageriePage() {
        try {
            System.out.println("Chargement de la page messagerie");
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/eu/telecomnancy/labfx/Messagerie.fxml"));
            Parent messagerie = loader.load();
    
            MessagerieController messagerie_controller = loader.getController();
            messagerie_controller.setSkeletonController(this);
    
            // Passer le pseudo du fournisseur à MessagerieController
            messagerie_controller.setInitialContact(supplierForMessaging);
            messagerie_controller.initializeListContact();
            supplierForMessaging = null; // Réinitialiser la variable après utilisation
    
            mainContent.getChildren().setAll(messagerie);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    public void updateProfile(){
        profil_controller.updateProfileInfo(currentUser);
    }

    
}


package eu.telecomnancy.labfx;

import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;



public class User {

    private int id;
    private String prenom;
    private String nom;
    private String pseudo;
    private String mail;
    private String phone;
    private String photoProfil;
    private String localisation;
    private LocalDate dateInscription;
    private String statusCompte;
    private String etatCompte;
    private int nbFlorain;
    private String historiqueFlorain;
    private Double note;

    
    public User(String mail) {
        this.mail = mail;
        loadUserFromDB();
    }

    private void loadUserFromDB() {
        String sql = "SELECT * FROM profil WHERE mail = ?";

        try (Connection conn = DataBase.getConnection(); // Utiliser DatabaseUtil pour obtenir la connexion
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, this.mail);
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                this.id = rs.getInt("id");
                this.prenom = rs.getString("prenom");
                this.nom = rs.getString("nom");
                this.pseudo = rs.getString("pseudo");
                this.phone = rs.getString("phone");
                this.photoProfil = rs.getString("photo_profil");
                this.localisation = rs.getString("localisation");
                String dateString = rs.getString("date_inscription");
                System.out.println("datestring" + dateString);
                if (dateString != null && !dateString.isEmpty()) {
                this.dateInscription = LocalDate.parse(dateString);
                } else {
                this.dateInscription = null; // ou une date par défaut si nécessaire
                }
                this.statusCompte = rs.getString("status_compte");
                this.etatCompte = rs.getString("etat_compte");
                this.nbFlorain = rs.getInt("nb_florain");
                this.historiqueFlorain = rs.getString("historique_florain");
                this.note = rs.getDouble("note");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    

    public void update() {
        String sql = "UPDATE profil SET prenom = ?, nom = ?, pseudo = ?, phone = ?, photo_profil = ?, localisation = ?, status_compte = ?, etat_compte = ?, nb_florain = ?, historique_florain = ?, note = ? WHERE mail = ?";

        try (Connection conn = DataBase.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, this.prenom);
            pstmt.setString(2, this.nom);
            pstmt.setString(3, this.pseudo);
            pstmt.setString(4, this.phone);
            pstmt.setString(5, this.photoProfil);
            pstmt.setString(6, this.localisation);
            pstmt.setString(7, this.statusCompte);
            pstmt.setString(8, this.etatCompte);
            pstmt.setInt(9, this.nbFlorain);
            pstmt.setString(10, this.historiqueFlorain);
            pstmt.setDouble(11, this.note);
            pstmt.setString(12, this.mail);

            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }


    // Getters et Setters

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    
    public String getPrenom() {
        return prenom;
    }
    
    public void setPrenom(String prenom) {
        this.prenom = prenom;
    }
    
    public String getNom() {
        return nom;
    }
    
    public void setNom(String nom) {
        this.nom = nom;
    }

    public String getMail() {
        return mail;
    }

    public String setMail(String mail) {
        return this.mail;
    }
    
    public String getPseudo() {
        return pseudo;
    }
    
    public void setPseudo(String pseudo) {
        this.pseudo = pseudo;
    }
    
    public String getPhone() {
        return phone;
    }
    
    public void setPhone(String phone) {
        this.phone = phone;
    }
    
    public String getPhotoProfil() {
        return photoProfil;
    }
    
    public void setPhotoProfil(String photoProfil) {
        this.photoProfil = photoProfil;
    }
    
    public String getLocalisation() {
        return localisation;
    }
    
    public void setLocalisation(String localisation) {
        this.localisation = localisation;
    }
    
    public LocalDate getDateInscription() {
        return dateInscription;
    }
    
    public void setDateInscription(LocalDate dateInscription) {
        this.dateInscription = dateInscription;
    }
    
    public String getStatusCompte() {
        return statusCompte;
    }
    
    public void setStatusCompte(String statusCompte) {
        this.statusCompte = statusCompte;
    }
    
    public String getEtatCompte() {
        return etatCompte;
    }
    
    public void setEtatCompte(String etatCompte) {
        if (etatCompte.equals("actif") || etatCompte.equals("sommeil")) {
            this.etatCompte = etatCompte;
        } else {
            throw new IllegalArgumentException("L'état du compte doit être 'actif' ou 'inactif'");
        }
    }
    
    public int getNbFlorain() {
        return nbFlorain;
    }
    
    public void setNbFlorain(int nbFlorain) {
        this.nbFlorain = nbFlorain;
    }
    
    public String getHistoriqueFlorain() {
        return historiqueFlorain;
    }
    
    public void setHistoriqueFlorain(String historiqueFlorain) {
        this.historiqueFlorain = historiqueFlorain;
    }
    
    public Double getNote() {
        return note;
    }
    
    public void setNote(Double note) {
        this.note = note;
    }
    
    public double calculateDistanceTo(User otherUser) {
        double[] thisLocation = getCoordinates(this.localisation);
        double[] otherLocation = getCoordinates(otherUser.getLocalisation());
    
        double distance = haversine(thisLocation[0], thisLocation[1], otherLocation[0], otherLocation[1]);
        System.out.println("Calcul de la distance entre " + this.localisation + " (" + thisLocation[0] + ", " + thisLocation[1] + ") et " + otherUser.getLocalisation() + " (" + otherLocation[0] + ", " + otherLocation[1] + ") : " + distance + " km");
        //print user city and other user city
        return distance;
    }
    

    // Méthode pour obtenir les coordonnées (latitude, longitude) d'une localisation
    private double[] getCoordinates(String cityName) {
        String line;
        InputStream inputStream;
        inputStream = getClass().getResourceAsStream("/eu/telecomnancy/labfx/cities.csv");
    
        try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {
            while ((line = br.readLine()) != null) {
                String[] cityData = line.split(",");
                if (cityData[0].equals("id")) {
                    continue; // Ignorer l'en-tête
                }
                // Vérifier si le nom de la ville correspond (en tenant compte des guillemets)
                String cityInCsv = cityData[4].replace("\"", ""); // Retirer les guillemets
                if (cityInCsv.equalsIgnoreCase(cityName)) {
                    double latitude = Double.parseDouble(cityData[6]);
                    double longitude = Double.parseDouble(cityData[7]);
                    return new double[]{latitude, longitude};
                }
            }
        } catch (IOException e) {
            System.err.println("Erreur lors de la lecture du fichier CSV : " + e.getMessage());
            e.printStackTrace();
        }
    return new double[]{0.0, 0.0}; // Retourner une valeur par défaut en cas d'échec
    }
    
    

    // Méthode Haversine pour calculer la distance entre deux points GPS
    private double haversine(double lat1, double lon1, double lat2, double lon2) {
        final int EARTH_RADIUS = 6371; // Rayon de la Terre en kilomètres

        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        lat1 = Math.toRadians(lat1);
        lat2 = Math.toRadians(lat2);

        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
        double c = 2 * Math.asin(Math.sqrt(a));
        return EARTH_RADIUS * c;
    }
}
